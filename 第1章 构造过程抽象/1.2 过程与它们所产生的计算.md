# 1.2 过程与它们所产生的计算

## 练习 1.9

下面几个过程各定义了一种加起来两个正整数的方法，它们都是基于过程 `inc`（它将参数增加 1）和 `dec`（它将参数减少 1）。

```Scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
```

请用代换模型展示这两个过程在求值  `(+ 4 5)` 时所产生的计算过程。这些计算过程是递归的还是迭代的？

---

第一个的计算过程如下，它是递归的：

1. `(+ 4 5)`
2. `(inc (+ 3 5))`
3. `(inc (inc (+ 2 5)))`
4. `(inc (inc (inc (+ 1 5))))`
5. `(inc (inc (inc (inc (+ 0 5)))))`
6. `(inc (inc (inc (inc 5))))`
7. `(inc (inc (inc 6)))`
8. `(inc (inc 7))`
9. `(inc 8)`
10. `9`

第二的计算过程如下，它是迭代的：

1. `(+ 4 5)`
2. `(+ 3 6)`
3. `(+ 2 7)`
4. `(+ 1 8)`
5. `(+ 0 9)`
6. `9`

## 练习 1.10

下面过程计算一个称为 Ackermann 函数的数学函数：

```Scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
```

下面各表达式的值是什么：

* `(A 1 10)`
* `(A 2 4)`
* `(A 3 3)`

请考虑下面的过程，其中的 `A` 就是上面定义的过程：

* `(define (f n) (A 0 n))`
* `(define (g n) (A 1 n))`
* `(define (h n) (A 2 n))`
* `(define (k n) (* 5 n n))`

请给出过程 `f`，`g` 和 `h` 对给定整数值 `n` 所计算的函数的数学定义。例如，`(k n)` 计算的是 ![5n^2](https://render.githubusercontent.com/render/math?math=5n%5E2)。

---

### 1. `(A 1 10)` 代换过程

1. `(A 1 10)`
2. `(A 0 (A 1 9))`
3. `(A 0 (A 0 (A 1 8)))`
4. `(A 0 (A 0 (A 0 (A 1 7))))`
5. `(A 0 (A 0 (A 0 (A 0 (A 1 6)))))`
6. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))`
7. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))`
8. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))`
9. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))`
10. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))`
11. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))`
12. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))`
13. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))`
14. `(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))`
15. `(A 0 (A 0 (A 0 (A 0 (A 0 32)))))`
16. `(A 0 (A 0 (A 0 (A 0 64))))`
17. `(A 0 (A 0 (A 0 128)))`
18. `(A 0 (A 0 256))`
19. `(A 0 512)`
20. `1024`

因此 `(A 1 n)` 等价于 ![2^n](https://render.githubusercontent.com/render/math?math=2%5En)。

### 2. `(A 2 4)` 代换过程

1. `(A 2 4)`
2. `(A 1 (A 2 3))`
3. `(A 1 (A 1 (A 2 2)))`
4. `(A 1 (A 1 (A 1 (A 2 1))))`
5. `(A 1 (A 1 (A 1 2)))`
6. `(A 1 (A 1 4))`
7. `(A 1 16)`
8. `65536`

因此 `(A x y)` 等价于 ![2^{x^y}](https://render.githubusercontent.com/render/math?math=2%5E%7Bx%5Ey%7D)。

### 3. `(A 3 3)` 代换过程

由上，`(A 3 3)` 等价于 ![2^{3^3}](https://render.githubusercontent.com/render/math?math=2%5E%7B3%5E3%7D)，即 134217728。

`(define (f n) (A 0 n))` 等价于 ![2n](https://render.githubusercontent.com/render/math?math=2n)

| 表达式                   | 等价于                                                                            |
|--------------------------|-----------------------------------------------------------------------------------|
| `(define (f n) (A 0 n))` | ![2n](https://render.githubusercontent.com/render/math?math=2n)                   |
| `(define (g n) (A 1 n))` | ![2^n](https://render.githubusercontent.com/render/math?math=2%5En)               |
| `(define (h n) (A 2 n))` | ![2^{2^n}](https://render.githubusercontent.com/render/math?math=2%5E%7B2%5En%7D) |

## 练习 1.11

函数 `f` 由如下的规则定义：如果 `n < 3`，那么 `f(n) = n`；如果 `n >= 3`，那么 `f(n) = f(n-1) + 2f(n-2) + 3f(n-3)`。请写一个采用递归计算过程计算 `f` 的过程，再写一个采用迭代计算过程计算 `f` 的过程。

---

递归版本：

[练习1.11 f-recursion.ss](<练习1.11 f-recursion.ss>)

```Scheme
(define (f-recursion x)
  (if (< x 3)
      x
      (+ (f-recursion (- x 1))
         (* 2 (f-recursion (- x 2)))
         (* 3 (f-recursion (- x 3))))))
```

迭代版本：

[练习1.11 f-iteration.ss](练习1.11 f-iteration.ss)

```Scheme
(define (f-iteration x)
  (f-iter 0 1 2 x))

(define (f-iter a b c x)
  (if (< x 3)
      c
      (f-iter b
              c
              (+ (* a 3) (* b 2) c)
              (- x 1))))
```

## 练习 1.12

下面数值模式称为**帕斯卡三角形**：

```plain text
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
   ...
```

三角形边界上的数都是 1，内部的每个数是位于它上面的两个数之和。请写一个过程，它采用递归计算过程计算出帕斯卡三角形。

---

```Scheme
; 计算杨辉三角（帕斯卡三角）第 row 行第 column 个数字
(define (pascals-triangle-value row column)
  (assert (positive-integer? row))
  (assert (positive-integer? column))
  (assert (>= row column))

  (if (or (= column 1) (= row column))
      1
      (+ (pascals-triangle-value (- row 1) (- column 1))
         (pascals-triangle-value (- row 1) column))))

(define (positive-integer? n)
  (and (integer? n)
       (> n 0)))

(assert (= 6
           (pascals-triangle-value 5 3)))
```

## 练习 1.13

证明 ![Fib(n)](https://render.githubusercontent.com/render/math?math=Fib(n)) 是最接近 ![\frac{\phi^n}{\sqrt{5}}](https://render.githubusercontent.com/render/math?math=%5Cfrac%7B%5Cphi%5En%7D%7B%5Csqrt%7B5%7D%7D) 的整数，其中 ![\phi=\frac{1+\sqrt{5}}{2}](https://render.githubusercontent.com/render/math?math=%5Cphi%3D%5Cfrac%7B1%2B%5Csqrt%7B5%7D%7D%7B2%7D)。

提示：利用归纳法和斐波那契数的定义，证明 ![Fib(n)=\frac{\phi^n-\gamma^n}{\sqrt{5}}](https://render.githubusercontent.com/render/math?math=Fib(n)%3D%5Cfrac%7B%5Cphi%5En-%5Cgamma%5En%7D%7B%5Csqrt%7B5%7D%7D)。

---

纯数学证明，借用一下 [练习 1.13](https://sicp.readthedocs.io/en/latest/chp1/13.html) 的作业。

## 练习 1.14

请画出有关的树，展示 1.2.2 节的过程 `count-change` 在将 11 美分换成硬币时所产生的计算过程。相对于被换现金量的增加，这一计算过程的空间和步数增长的阶各是什么？

---

计算过程如下：

```Scheme
(cc 11 5)

(+ (cc 11 4)
   (cc -39 5))

(+ (cc 11 3)
   (cc -14 4))

(+ (cc 11 2)
   (cc 1 3))

(+ (+ (cc 11 1)
      (cc 6 2))
   (+ (cc 1 2)
      (cc -9 3)))

(+ (+ (+ (cc 11 0)
         (cc 10 1))
      (+ (cc 6 1)
         (cc 1 2)))
   (+ (cc 1 1)
      (cc -4 2)))

(+ (+ (+ (cc 10 0)
         (cc 9 1))
      (+ (+ (cc 6 0)
            (cc 5 1))
         (+ (cc 1 1)
            (cc -4 2))))
   (+ (cc 1 0)
      (cc 0 1)))

(+ (+ (+ (cc 9 0)
         (cc 8 1))
      (+ (+ (cc 5 0)
            (cc 4 1))
         (+ (cc 1 0)
            (cc 0 1))))
   1)

(+ (+ (+ (cc 8 0)
         (cc 7 1))
      (+ (+ (cc 4 0)
            (cc 3 1))
         1))
   1)

(+ (+ (+ (cc 7 0)
         (cc 6 1))
      (+ (+ (cc 3 0)
            (cc 2 1))
         1))
   1)

(+ (+ (+ (cc 6 0)
         (cc 5 1))
      (+ (+ (cc 2 0)
            (cc 1 1))
         1))
   1)

(+ (+ (+ (cc 5 0)
         (cc 4 1))
      (+ (+ (cc 1 0)
            (cc 0 1))
         1))
   1)

(+ (+ (+ (cc 4 0)
         (cc 3 1))
      2)
   1)

(+ (+ (+ (cc 3 0)
         (cc 2 1))
      2)
   1)

(+ (+ (+ (cc 2 0)
         (cc 1 1))
      2)
   1)

(+ (+ (+ (cc 1 0)
         (cc 0 1))
      2)
   1)

4
```

计算 `(count-amount n)` 的过程相当于后序遍历一个高度为 `n` 的二叉树，时间复杂度为 ![O(N^2)](https://render.githubusercontent.com/render/math?math=O(N%5E2))，空间复杂度为 ![O(N)](https://render.githubusercontent.com/render/math?math=O(N))。

## 练习 1.15

在角 `x`（弧度制）足够小时，其正弦值可以用 ![\sin{x}\approx x](https://render.githubusercontent.com/render/math?math=%5Csin%7Bx%7D%5Capprox%20x) 计算，而三角恒等式

![\sin{x}=3\sin{\frac{x}{3}}-4\sin^3{\frac{x}{3}}](https://render.githubusercontent.com/render/math?math=%5Csin%7Bx%7D%3D3%5Csin%7B%5Cfrac%7Bx%7D%7B3%7D%7D-4%5Csin%5E3%7B%5Cfrac%7Bx%7D%7B3%7D%7D)

可以减小 `sin` 的参数（如果一个角不大于 0.1，我们就认为它“足够小”）。这个想法体现在下述过程中：

```Scheme
(define (cube x) (* x x x))

(define (p x) (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
```

1. 在求值 `(sine 12.15)` 时， `p` 将被使用多少次？

2. 在求值 `(sine a)` 时，由过程 `sine` 所产生的计算过程使用的空间和步数增长的阶是什么（以 `a` 的函数计）。

---

1. 求值过程如下：

```Scheme
(sine 12.15)

(p (sine 4.05))

(p (p (sine 1.35)))

(p (p (p (sine 0.45))))

(p (p (p (p (sine 0.15)))))

(p (p (p (p (p (sine 0.05))))))
```

`p` 将被使用 5 次。

2. 由上，对于任意的 `a`，`(sine a)` 需要调用 `p` 的次数为 ![\lceil\log_3{\frac{a}{0.1}}\rceil](https://render.githubusercontent.com/render/math?math=%5Clceil%5Clog_3%7B%5Cfrac%7Ba%7D%7B0.1%7D%7D%5Crceil)
，因此空间和时间复杂度都是 ![O(\log{a})](https://render.githubusercontent.com/render/math?math=O(%5Clog%7Ba%7D))。
