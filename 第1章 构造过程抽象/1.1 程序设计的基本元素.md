# 1.1 程序设计的基本元素.md

## 练习 1.1

下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。

```Scheme
10
```

10

```Scheme
(+ 5 3 4)
```

12

```Scheme
(- 9 1)
```

8

```Scheme
(/ 6 2)
```

3

```Scheme
(+ (* 2 4) (- 4 6))
```

6

```Scheme
(define a 3)
(define b (+ a 1))
```

a = 3, b = 4

```Scheme
(+ a b (* a b))
```

19

```Scheme
(= a b)
```

false

```Scheme
(if (and (> b a) (< b (* a b)))
    b
    a)
```

4

```Scheme
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
```

16

```Scheme
(+ 2 (if (> b a) b a))
```

6

```Scheme
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
```

16

## 练习 1.2

请将下面表达式变换为前缀形式：

![\frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)}](https://render.githubusercontent.com/render/math?math=%5Cfrac%7B5%2B4%2B(2-(3-(6%2B%5Cfrac%7B4%7D%7B5%7D)))%7D%7B3(6-2)(2-7)%7D)

---

```Scheme
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
```

## 练习 1.3

请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。

---

```Scheme
(define (max-2-sum a b c)
  (- (+ a b c)
     (min a (min b c))))

(define (min a b)
  (if (< a b) a b))
```

## 练习 1.4

请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面过程的行为：

```Scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

---

调用 `a-plus-abs-b`，对表达式 `((if (> b 0) + -) a b))` 求值：

1. 计算各子表达式的值，即 `a` 和 `b`；

2. 计算运算符，根据 `(if (> b 0) + -)`，当 `b > 0` 时为 `+`，当 `b <= 0` 时为 `-`；

3. 根据上一步的结果，`b > 0` 时计算 `(+ a b)`， `b <= 0` 时计算 `(- a b)`。

## 练习 1.5

Ben Bitdiddle 发明了一种检测方法，能够确定解释器究竟采用应用序还是正则序求值。他定义了下面两个过程：

```Scheme
(define (p) (p))

(define (test x y)
  (if (= x 0) 0 y))
```

而后他求值下面的表达式：

```Scheme
(test 0 (p))
```

如果解释器采用的应用序求值，会看到什么样的情况；如果采用正则序求值，又会看到什么情况？请对你的回答做出解释。（无论采用正则序还是应用序，假定特殊形式 `if` 的求值规则总是一样的，其中的谓词部分先行求值，根据其结果确定随后求值的子表达式。）

---

如果采用应用序求值，`(test 0 (p))` 将陷入无限循环。解释器求值 `(p)`，得到的依然是 `(p)`，因此陷入循环。

如果采用的正则序求值，展开和归约过程如下：

```Scheme
(test 0 (p))

(if (= 0 0) 0 (p)) ; (= 0 0) 判断为 true，返回 0

0
```

因此正则序求值的解释器会正常返回 0。
