# 1.1 程序设计的基本元素

## 练习 1.1

下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。

```Scheme
10
```

10

```Scheme
(+ 5 3 4)
```

12

```Scheme
(- 9 1)
```

8

```Scheme
(/ 6 2)
```

3

```Scheme
(+ (* 2 4) (- 4 6))
```

6

```Scheme
(define a 3)
(define b (+ a 1))
```

a = 3, b = 4

```Scheme
(+ a b (* a b))
```

19

```Scheme
(= a b)
```

false

```Scheme
(if (and (> b a) (< b (* a b)))
    b
    a)
```

4

```Scheme
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
```

16

```Scheme
(+ 2 (if (> b a) b a))
```

6

```Scheme
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
```

16

## 练习 1.2

请将下面表达式变换为前缀形式：

![\frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)}](https://render.githubusercontent.com/render/math?math=%5Cfrac%7B5%2B4%2B(2-(3-(6%2B%5Cfrac%7B4%7D%7B5%7D)))%7D%7B3(6-2)(2-7)%7D)

---

```Scheme
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
```

## 练习 1.3

请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。

---

```Scheme
(define (max-2-sum a b c)
  (- (+ a b c)
     (min a (min b c))))

(define (min a b)
  (if (< a b) a b))
```

## 练习 1.4

请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面过程的行为：

```Scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

---

调用 `a-plus-abs-b`，对表达式 `((if (> b 0) + -) a b))` 求值：

1. 计算各子表达式的值，即 `a` 和 `b`；

2. 计算运算符，根据 `(if (> b 0) + -)`，当 `b > 0` 时为 `+`，当 `b <= 0` 时为 `-`；

3. 根据上一步的结果，`b > 0` 时计算 `(+ a b)`， `b <= 0` 时计算 `(- a b)`。

## 练习 1.5

Ben Bitdiddle 发明了一种检测方法，能够确定解释器究竟采用应用序还是正则序求值。他定义了下面两个过程：

```Scheme
(define (p) (p))

(define (test x y)
  (if (= x 0) 0 y))
```

而后他求值下面的表达式：

```Scheme
(test 0 (p))
```

如果解释器采用的应用序求值，会看到什么样的情况；如果采用正则序求值，又会看到什么情况？请对你的回答做出解释。（无论采用正则序还是应用序，假定特殊形式 `if` 的求值规则总是一样的，其中的谓词部分先行求值，根据其结果确定随后求值的子表达式。）

---

如果采用应用序求值，`(test 0 (p))` 将陷入无限循环。解释器求值 `(p)`，得到的依然是 `(p)`，因此陷入循环。

如果采用的正则序求值，展开和归约过程如下：

```Scheme
(test 0 (p))

(if (= 0 0) 0 (p)) ; (= 0 0) 判断为 true，返回 0

0
```

因此正则序求值的解释器会正常返回 0。

## 1.6

Alyssa P. Hacker 看不出为什么需要将 `if` 提供为一种特殊形式，她问：“为什么不能直接通过 `cond` 将它定义为一个常规过程呢？” Alyssa 的朋友 Eva Lu Ator 断言确实可以这样做，并定义了 `if` 的一个新版本：

```Scheme
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
```

Eva 给 Alyssa 演示她的程序：

```Scheme
(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
```

她很高兴地用自己的 `new-if` 重写了求平方根的程序：

```Scheme
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
```

当 Alyssa 试着用这个过程去计算平方根时会发生什么事情呢？请给出解释。

---

应用序求值的情况下，在调用 `new-if` 前，`then-clause` 和 `else-clause` 都会被求值，这会导致 `sqrt-iter` 会无限地递归调用。

## 练习 1.7

对于确定很小的数字的平方根而言，在计算平方根中使用的检测 `good-enough?` 是很不好的。还有，在现实的计算机里，算术运算总是以一定的有限精度进行的。这也会使我们的检测不适合非常大的数的计算。请解释上述论断，用例子说明对很小和很大的数，这种检测都可能失败，实现 `good-enough?` 的另一种策略是监视猜测值在从一次迭代到下一次的变化情况，当改变值对于猜测值的比率很小时就结束。请设计一个采用这种终止测试方式的平方根过程。对于很大的数和很小的数，这一方式都能工作吗？

---

在 `x` 特别小或者特别大时，`good-enough?` 函数确实会出现错误：

| x      | 计算出的平方根 | 实际的平方根 |
|--------|----------------|--------------|
| 0.0001 | 0.0323         | 0.01         |
| 1e35   | 无限循环       | 3.1622e17    |

我给出的改进版平方根算法：

[1.7 my-sqrt.ss](<1.7 my-sqrt.ss>)

```Scheme
(define (my-sqrt x)
  (sqrt-iter 0.0 1.0 x))

(define (sqrt-iter prev-guess guess x)
  (if (new-good-enough? prev-guess guess)
    guess
    (sqrt-iter guess (improve guess x) x)))

; 当 (prev-guess - guess) / guess < 0.001 时停止迭代
(define (new-good-enough? prev-guess guess)
  (< (abs (/ (- prev-guess guess) guess)) 0.001))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))
```

该算法对很大的数和很小的数都有不错的效果：

| x      | 计算出的平方根 | 实际的平方根 |
|--------|----------------|--------------|
| 0.0001 | 0.0100         | 0.01         |
| 1e35   | 3.1622e17      | 3.1622e17    |

## 练习 1.8

求立方根的牛顿法基于如下事实，如果 `y` 是 `x` 的立方根的近似值，那么下式将给出一个更好的近似值：

![\frac{x/{y^2}+2y}{3}](https://render.githubusercontent.com/render/math?math=%5Cfrac%7Bx%2F%7By%5E2%7D%2B2y%7D%7B3%7D)

请利用这一公式实现一个类似于平方根的求立方根的过程。（在 1.3.4 节里，我们将看到如何实现一般性的牛顿法，作为这些求平方根和立方根过程的抽象。）

---

[1.8 cude-root.ss](<1.8 cude-root.ss>)

```Scheme
(define (cube-root x)
  (cube-root-iter 0.0 1.0 x))

(define (cube-root-iter prev-guess guess x)
  (if (good-enough? prev-guess guess)
      guess
      (cube-root-iter guess 
                      (improve guess x) 
                      x)))

(define (good-enough? prev-guess guess)
  (< (abs (/ (- prev-guess guess) guess)) 0.001))

(define (improve guess x)
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))

(define (square x)
  (* x x))
```

| x        | 计算的立方根 | 实际立方根 |
|----------|--------------|------------|
| 27       | 3.0000       | 3          |
| 0.000001 | 0.0100       | 0.1        |
| 1e35     | 4.6416e11    | 4.6416e11  |
